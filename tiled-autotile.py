#!/usr/bin/env python3

from typing import Tuple, List
from PIL import Image
from enum import Enum, auto
import sys
import os

TILE_SIZE = 32

SUBTILE_SIZE = TILE_SIZE // 2


class Autotile(Enum):
    # These subtile combinations were generated by the 'subtile_combinations.py' script.
    # Terrain
    T = (
        auto(), 2, 3, 7, 7, (
            ((0, 2), (1, 3), (1, 2), (0, 3)),
            ((2, 2), (1, 3), (1, 2), (2, 3)),
            ((2, 2), (3, 3), (3, 2), (2, 3)),
            ((0, 2), (3, 3), (3, 2), (0, 3)),
            ((2, 4), (3, 1), (1, 4), (2, 3)),
            ((2, 4), (3, 1), (1, 4), (2, 1)),
            ((2, 4), (1, 3), (1, 4), (2, 1)),
            ((0, 4), (1, 3), (1, 4), (0, 3)),
            ((2, 4), (1, 3), (1, 4), (2, 3)),
            ((2, 4), (3, 3), (3, 4), (2, 3)),
            ((0, 4), (3, 3), (3, 4), (0, 3)),
            ((2, 4), (3, 1), (3, 0), (2, 3)),
            ((2, 0), (3, 1), (3, 0), (2, 1)),
            ((2, 0), (1, 3), (1, 4), (2, 1)),
            ((0, 4), (1, 5), (1, 4), (0, 5)),
            ((2, 4), (1, 5), (1, 4), (2, 5)),
            ((2, 4), (3, 5), (3, 4), (2, 5)),
            ((0, 4), (3, 5), (3, 4), (0, 5)),
            ((2, 4), (1, 3), (3, 0), (2, 3)),
            ((2, 0), (1, 3), (3, 0), (2, 3)),
            ((2, 0), (1, 3), (1, 4), (2, 3)),
            ((0, 2), (1, 5), (1, 2), (0, 5)),
            ((2, 2), (1, 5), (1, 2), (2, 5)),
            ((2, 2), (3, 5), (3, 2), (2, 5)),
            ((0, 2), (3, 5), (3, 2), (0, 5)),
            ((2, 2), (3, 1), (1, 2), (2, 3)),
            ((2, 2), (3, 1), (1, 2), (2, 1)),
            ((2, 2), (1, 3), (1, 2), (2, 1)),
            ((0, 4), (3, 1), (1, 4), (0, 3)),
            ((2, 4), (3, 3), (3, 4), (2, 1)),
            ((2, 0), (3, 1), (1, 4), (2, 3)),
            ((2, 4), (1, 3), (3, 0), (2, 1)),
            ((2, 4), (1, 5), (3, 0), (2, 5)),
            ((2, 0), (1, 5), (3, 0), (2, 5)),
            ((2, 0), (1, 5), (1, 4), (2, 5)),
            ((0, 4), (3, 1), (3, 0), (0, 3)),
            ((2, 0), (3, 3), (3, 4), (2, 1)),
            ((0, 2), (3, 1), (1, 2), (0, 3)),
            ((2, 2), (3, 3), (3, 2), (2, 1)),
            ((2, 4), (3, 1), (3, 0), (2, 1)),
            ((2, 0), (3, 1), (1, 4), (2, 1)),
            (),
            ((0, 4), (1, 3), (3, 0), (0, 3)),
            ((2, 0), (3, 3), (3, 4), (2, 3)),
            ((0, 4), (1, 5), (3, 0), (0, 5)),
            ((2, 0), (3, 5), (3, 4), (2, 5)),
            ((2, 0), (3, 1), (3, 0), (2, 3)),
            ((2, 0), (1, 3), (3, 0), (2, 1)),
            ()
        )
    )
    # Wall
    W = (
        auto(), 2, 2, 4, 4, (
            ((0, 0), (1, 1), (1, 0), (0, 1)),
            ((2, 0), (1, 1), (1, 0), (2, 1)),
            ((2, 0), (3, 1), (3, 0), (2, 1)),
            ((0, 0), (3, 1), (3, 0), (0, 1)),
            ((0, 2), (1, 1), (1, 2), (0, 1)),
            ((2, 2), (1, 1), (1, 2), (2, 1)),
            ((2, 2), (3, 1), (3, 2), (2, 1)),
            ((0, 2), (3, 1), (3, 2), (0, 1)),
            ((0, 2), (1, 3), (1, 2), (0, 3)),
            ((2, 2), (1, 3), (1, 2), (2, 3)),
            ((2, 2), (3, 3), (3, 2), (2, 3)),
            ((0, 2), (3, 3), (3, 2), (0, 3)),
            ((0, 0), (1, 3), (1, 0), (0, 3)),
            ((2, 0), (1, 3), (1, 0), (2, 3)),
            ((2, 0), (3, 3), (3, 0), (2, 3)),
            ((0, 0), (3, 3), (3, 0), (0, 3))
        )
    )
    # Unchanged (waterfall, objects)
    U = (auto(), 2, 3, 2, 3, ())

    def __init__(
            self,
            id_: int,
            width_autotile: int,
            height_autotile: int,
            width_tiled: int,
            height_tiled: int,
            combinations: List[Tuple]
    ):
        self.id = id_
        self.width_autotile = width_autotile
        self.height_autotile = height_autotile
        self.width_autotile_px = self.width_autotile * TILE_SIZE
        self.height_autotile_px = self.height_autotile * TILE_SIZE
        self.width_tiled = width_tiled
        self.height_tiled = height_tiled
        self.width_tiled_px = self.width_tiled * TILE_SIZE
        self.height_tiled_px = self.height_tiled * TILE_SIZE
        self.combinations = combinations


class Layout(Enum):
    A1 = (
        auto(),
        (
            (Autotile.T, Autotile.T, Autotile.T, Autotile.T, Autotile.T, Autotile.T, Autotile.T, Autotile.U),
            (Autotile.T, Autotile.T, Autotile.T, Autotile.T, Autotile.T, Autotile.T, Autotile.T, Autotile.U),
            (Autotile.T, Autotile.T, Autotile.T, Autotile.U, Autotile.T, Autotile.T, Autotile.T, Autotile.U),
            (Autotile.T, Autotile.T, Autotile.T, Autotile.U, Autotile.T, Autotile.T, Autotile.T, Autotile.U)
        )
    )
    A2 = (
        auto(),
        (
            (Autotile.T, Autotile.T, Autotile.T, Autotile.T, Autotile.T, Autotile.T, Autotile.T, Autotile.T),
            (Autotile.T, Autotile.T, Autotile.T, Autotile.T, Autotile.T, Autotile.T, Autotile.T, Autotile.T),
            (Autotile.T, Autotile.T, Autotile.T, Autotile.T, Autotile.T, Autotile.T, Autotile.T, Autotile.T),
            (Autotile.T, Autotile.T, Autotile.T, Autotile.T, Autotile.T, Autotile.T, Autotile.T, Autotile.T)
        )
    )
    A3 = (
        auto(),
        (
            (Autotile.W, Autotile.W, Autotile.W, Autotile.W, Autotile.W, Autotile.W, Autotile.W, Autotile.W),
            (Autotile.W, Autotile.W, Autotile.W, Autotile.W, Autotile.W, Autotile.W, Autotile.W, Autotile.W),
            (Autotile.W, Autotile.W, Autotile.W, Autotile.W, Autotile.W, Autotile.W, Autotile.W, Autotile.W),
            (Autotile.W, Autotile.W, Autotile.W, Autotile.W, Autotile.W, Autotile.W, Autotile.W, Autotile.W)
        )
    )
    A4 = (
        auto(),
        (
            (Autotile.T, Autotile.T, Autotile.T, Autotile.T, Autotile.T, Autotile.T, Autotile.T, Autotile.T),
            (Autotile.W, Autotile.W, Autotile.W, Autotile.W, Autotile.W, Autotile.W, Autotile.W, Autotile.W),
            (Autotile.T, Autotile.T, Autotile.T, Autotile.T, Autotile.T, Autotile.T, Autotile.T, Autotile.T),
            (Autotile.W, Autotile.W, Autotile.W, Autotile.W, Autotile.W, Autotile.W, Autotile.W, Autotile.W),
            (Autotile.T, Autotile.T, Autotile.T, Autotile.T, Autotile.T, Autotile.T, Autotile.T, Autotile.T),
            (Autotile.W, Autotile.W, Autotile.W, Autotile.W, Autotile.W, Autotile.W, Autotile.W, Autotile.W),
        )
    )

    def __init__(self, id_: int, autotiles: Tuple):
        self.id = id_
        self.autotiles = autotiles
        self.width_tiled = max(sum(autotile.width_tiled for autotile in row) for row in self.autotiles)
        self.height_tiled = max(sum(autotile.height_tiled for autotile in col) for col in zip(*self.autotiles))
        self.width_tiled_px = self.width_tiled * TILE_SIZE
        self.height_tiled_px = self.height_tiled * TILE_SIZE


def run():
    layout_label = os.path.splitext(sys.argv[1])[0][-2:]
    if layout_label == 'A1':
        layout = Layout.A1
    elif layout_label == 'A2':
        layout = Layout.A2
    elif layout_label == 'A3':
        layout = Layout.A3
    elif layout_label == 'A4':
        layout = Layout.A4
    else:
        layout = None
        print('Unsupported layout: "{}"'.format(layout_label))
        exit(1)
    source = Image.open(sys.argv[1])
    target = unpack(source, layout)
    filename = '_unpacked'.join(os.path.splitext(sys.argv[1]))
    target.save(filename)


def unpack(source: Image, layout: Layout) -> Image:
    target = Image.new('RGBA', (layout.width_tiled_px, layout.height_tiled_px))

    source_y = 0
    target_y = 0
    for row in layout.autotiles:
        source_x = 0
        target_x = 0

        for autotile in row:
            left = source_x * TILE_SIZE
            upper = source_y * TILE_SIZE
            right = left + autotile.width_autotile_px
            lower = upper + autotile.height_autotile_px
            autotile_source = source.crop((left, upper, right, lower))

            left = target_x * TILE_SIZE
            upper = target_y * TILE_SIZE

            if autotile == Autotile.U:
                target.paste(autotile_source, (left, upper))
            else:
                convert_autotile(autotile, autotile_source, target, (left, upper))

            source_x += autotile.width_autotile
            target_x += autotile.width_tiled

        # All autotiles within a row are of equal height.
        row_height_tiled = max(autotile.height_tiled for autotile in row)
        source_y += row[0].height_autotile
        target_y += row_height_tiled

    return target


def convert_autotile(autotile: Autotile, source: Image, target: Image, target_offset_px: Tuple[int, int]):
    # Target coordinates as subtile coordinates.
    target_x = 0
    target_y = 0
    for combination in autotile.combinations:
        if combination:
            copy_subtiles(source, target, combination, target_offset_px, (target_x, target_y))
        target_x += 1
        target_x %= autotile.width_tiled
        if target_x == 0:
            target_y += 1


def copy_subtiles(
        source: Image,
        target: Image,
        combination: Tuple,
        target_offset_px: Tuple[int, int],
        target_coords: Tuple[int, int]
):
    target_x = target_offset_px[0] + target_coords[0] * TILE_SIZE
    target_y = target_offset_px[1] + target_coords[1] * TILE_SIZE
    # Combination order is: top-left, bottom-right, top-right, bottom-left.
    for (x, y), (target_offset_x, target_offset_y) in zip(combination, ((0, 0), (1, 1), (1, 0), (0, 1))):
        left = SUBTILE_SIZE * x
        upper = SUBTILE_SIZE * y
        right = left + SUBTILE_SIZE
        lower = upper + SUBTILE_SIZE

        subtile = source.crop((left, upper, right, lower))
        left = target_x + SUBTILE_SIZE * target_offset_x
        upper = target_y + SUBTILE_SIZE * target_offset_y
        target.paste(subtile, (left, upper))


if __name__ == '__main__':
    if len(sys.argv) < 2:
        print("Usage: {} input_file".format(sys.argv[0]))
        exit(1)
    run()
